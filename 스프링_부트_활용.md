## **스프링 부트 활용**
  * SpringApplication
    * 참고) https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application
    * 스프링 실행
      ```java
      SpringApplication.run(Application.class, args);
      // ↑ 요렇게 쓰면 스프링 애플리케이션이 제공하는 다양한 커스터마이징 기능을 사용하기가 어렵다.
      ```
      * 커스터마이징 가능 ← 인스턴스를 만들어서 활용하는 방식
      ```java
      SpringApplication app = new SpringApplication(Application.class);
      app.run(args);
      // ↑ 위의 코드와 결과는 동일하지만 커스터마이징이 가능함.
      ```
      * Application.class : @SpringBootApplication 애노테이션 붙인 클래스
    * 기본 로그 레벨 : INFO
      * 추후에 더 살펴볼 예정
      * 인텔리제이 실행 옵션에서 "VM Option:" 에 "-Ddebug" 를 설정하거나 "Program arguments" 에 "--debgug" 값을 설정하면 디버그 모드로 애플리케이션이 동작. 로그도 디버그 레벨까지 내려감.
        * 디버그 레벨로 로그 찍을 때 어떤 자동설정이 적용됐는지, 왜 적용이 안됐는지 파악 가능.
    * FailureAnalyzer
      * 에러메세지를 좀 더 예쁘게 출력해주는 기능.
      * 레퍼런스 문서 참고
    * 배너
      * banner.txt | gif | jpg | png
      * classpath 또는 spring.banner.location
        * application.properties 에서 설정
      * ${spring-boot.version} 등의 변수를 사용할 수 있음.
        * 일부 변수는 MF 파일 생성되어야 사용 가능. (jar로 패키징 한 후 실행하면 보임)
      * Banner 클래스 구현하고 SpringApplication.setBanner()로 설정 가능.
      * 배너 끄는 방법
        * SpringApplication.setBannerMode(Banner.Mode.OFF)
    * SpringApplicationBuilder로 빌더 패턴 사용 가능
      * 커스터마이징 가능
      ```java
      @SpringBootApplication
      public class Application {
          public static void main(String[] args) {
              new SpringApplicationBuilder()
                      .sources(Application.class)
                      .run(args);
          }
      }
      ```
    * ApplicationEvent 등록
      * 참고) https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners
      * ApplicationContext를 만들기 전에 사용하는 리스너는 @Bean으로 등록할 수 없다. 대신 아래와 같이 활용.
        * SpringApplication.addListeners()
          ```java
          /* SampleListener.java */
          public class SampleListener implements ApplicationListener<ApplicationStartingEvent> {

              @Override
              public void onApplicationEvent(ApplicationStartingEvent applicationStartingEvent) {
                  System.out.println("=======================");
                  System.out.println("Application is starting");
                  System.out.println("=======================");
              }
          }
          ```
          ```java
          /* Application.java */
          @SpringBootApplication
          public class Application {
              public static void main(String[] args) {
                  SpringApplication app = new SpringApplication(Application.class);
                  app.addListeners(new SampleListener());
                  app.setWebApplicationType(WebApplicationType.NONE);
                  app.run(args);
              }
          }
          ```
      * ApplicationContext를 만든 이후에 사용하는 리스너는 @Bean으로 등록 가능.
        ```java
        /* SampleListener.java */
        @Component
        public class SampleListener2 implements ApplicationListener<ApplicationStartedEvent> {
            @Override
            public void onApplicationEvent(ApplicationStartedEvent applicationStartedEvent) {
                System.out.println("=======================");
                System.out.println("Started");
                System.out.println("=======================");
            }
        }
        ```
        ```java
        /* Application.java */
        @SpringBootApplication
        public class Application {
            public static void main(String[] args) {
                SpringApplication app = new SpringApplication(Application.class);
                app.setWebApplicationType(WebApplicationType.NONE);
                app.run(args);
            }
        }
        ```
    * WebApplicationType 설정
      * WebApplicationType.NONE / .SERVLET / .REACTIVE 존재
        * 기본적으로 서블릿 웹 MVC가 있으면 SERVLET로 동작. 스프링 WebFlux가 들어있으면 REACTIVE로 동작.
          * 서블릿이 없고 리액티브만 있으면 리액티브로 동작하지만 서블릿이 있으면 무조건 서블릿으로 동작. 둘 다 없으면 NONE.
            * 서블릿도 있고 WebFlux도 있는데 그 상황에서 WebFlux를 선택하고자 하면 `app.setWebApplicationType(WebApplicationType.REACTIVE)`
        ```java
        /* Application.java */
        @SpringBootApplication
        public class Application {
            public static void main(String[] args) {
                SpringApplication app = new SpringApplication(Application.class);
                app.setWebApplicationType(WebApplicationType.NONE);
                app.run(args);
            }
        }
        ```
    * 애플리케이션 아규먼트 사용하기
      * 인텔리제이 실행 설정의 "Program arguments:" 부분에 "--" 로 값 넣어주는 영역
      * "VM options:" 부분은 JVM 옵션임. JVM 옵션은 애플리케이션 argument가 아님!
        * 예) VM options: "-Dfoo" / Program arguments: "--bar"
          ```java
          /* ArgsCheck.java */
          @Component
          public class ArgsCheck {

              // 어떤 Bean의 생성자가 한개이고 그 생성자의 파라미터가 Bean일 경우 그 Bean을 스프링이 알아서 주입해줌
              public ArgsCheck(ApplicationArguments arguments) {
                  // foo: false
                  // bar: true
                  System.out.println("foo: " + arguments.containsOption("foo"));
                  System.out.println("bar: " + arguments.containsOption("bar"));
              }
          }
          ```
          * maven jar 패키징 이후에 `java -jar spring-boot-getting-started-1.0-SNAPSHOT.jar -Dfoo --bar` 로 실행해도 동일함
    * 애플리케이션 실행한 뒤 뭔가 실행하고 싶을 때
      * 아래 둘 다 JVM 옵션은 받지 못함
      * ApplicationRunner (추천) 또는 CommandLineRunner
         * ApplicationRunner 예)
           * 추상화된 기능 활용가능. 조금 더 고급화된 API를 통해 argument 사용가능. (ApplicationArguments)
           ```java
           /* ArgsCheck.java */
           @Component
           public class ArgsCheck implements ApplicationRunner {

               @Override
               public void run(ApplicationArguments args) throws Exception {
                   // foo: false
                   // bar: true
                   System.out.println("foo: " + args.containsOption("foo"));
                   System.out.println("bar: " + args.containsOption("bar"));
               }
           }
           ```
         * CommandLineRunner 예)
           * argument 를 상대적으로 보다 직접적으로 다뤄야 함.
           ```java
           /* ArgsCheck.java */
           @Component
           public class ArgsCheck implements CommandLineRunner {
               @Override
               public void run(String... args) throws Exception {
                   //--bar
                   Arrays.stream(args).forEach(System.out::println);
               }
           }
           ```
      * ApplicationRunner 를 implement 하는 class가 여러개일 경우 순서 지정 가능
        * `@Order(1)` 숫자가 낮을수록 우선순위 높음
***
  * 외부 설정
    * 참고) https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config
    * 사용할 수 있는 외부 설정
      * properties
        * src > main > resources 의 application.properties
        * 예) `changhee.name = changhee`
      * YAML
      * 환경 변수
      * 커맨드라인 아규먼트
        * 예) `java -jar target/springinit-0.0.1-SNAPSHOT.jar --changhee.name=leechangheelee`
    * 프로퍼티 값 사용 (@Value)
      ```java
      /* SampleRunner.java */
      @Component
      public class SampleRunner implements ApplicationRunner {

          @Value("${changhee.fullName}")
          private String name;

          @Value("${changhee.age}")
          private int age;

          @Override
          public void run(ApplicationArguments args) throws Exception {
              System.out.println("===========================");
              System.out.println(name);
              System.out.println(age);
              System.out.println("===========================");
          }
      }
      ```
    * 테스트용 프로퍼티 설정
      * src > test > resources 의 application.properties 생성
        * 인텔리제이 Project Structure > Modules 에서 src > test > resources 디렉토리에 [Test Resources] 마크해줌
        * `changhee.name = changheelee`
      ```java
      /* SpringinitApplicationTest.java */
      @SpringBootTest
      public class SpringinitApplicationTest {

          @Autowired
          Environment environment;
          // ↑ src > test > resource 아래의 application.properties 가
          //   src > main > resource 아래의 application.properties 를 덮어씀

          @Test
          public void contextLoads() {
              assertThat(environment.getProperty("changhee.name"))
                      .isEqualTo("changhee"); // "changheelee" 로 덮어져서 에러발생
          }
      }
      ```
        * 두 application.properties 간 키가 다른 경우, 테스트 실행시 에러 발생
          * 소스 빌드 후 테스트 빌드시 application.properties 를 갈아끼우는데, 프로덕션 코드에서 필요한 키에 대한 값을 못찾음
          * test 아래의 application.properties 를 생성하지 않거나 삭제할 시 src > main > resources 의 파일 값 사용
      * 오버라이딩을 피하기 위해 테스트용 프로퍼티 파일을 다른이름으로 줄 수 있음
        * 예) src > test > resources > test.properties  
          ```java
          /* SpringinitApplicationTest.java */
          ...
          @TestPropertySource(locations = "classpath:/test.properties")
          ...
          ```
    * 프로퍼티 우선순위
      1. 유저 홈 디렉토리에 있는 spring-boot-dev-tools.properties
      2. 테스트에 있는 @TestPropertySource  
        `@TestPropertySource(properties = "changhee.name=changhee2")`
      3. @SpringBootTest 애노테이션의 properties 애트리뷰트  
        `@SpringBootTest(properties = "changhee.name=changhee2")`
      4. 커맨드 라인 아규먼트
      5. SPRING_APPLICATION_JSON (환경변수 또는 시스템 프로퍼티) 에 들어있는 프로퍼티
      6. ServletConfig 파라미터
      7. ServletContext 파라미터
      8. java:comp/env JNDI 애트리뷰트
      9. System.getProperties() 자바 시스템 프로퍼티
      10. OS 환경 변수
      11. RandomValuePropertySource
      12. JAR 밖에 있는 특정 프로파일용 application properties
      13. JAR 안에 있는 특정 프로파일용 application properties
      14. JAR 밖에 있는 application properties
      15. JAR 안에 있는 application properties
      16. @PropertySource
      17. 기본 프로퍼티 (SpringApplication.setDefaultProperties)
    * application.properties 우선 순위 (높은게 낮은걸 덮어 씀)
      1. file:./config/
      2. file:./
      3. classpath:/config/
      4. classpath:/
    * 랜덤값 설정하기
      * ${random.*}  
        `changhee.age = ${random.int}`
    * 플레이스 홀더
      * name = changhee
      * fullName = ${name} Lee
