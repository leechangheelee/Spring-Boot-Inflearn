## **스프링 부트 활용**
  * SpringApplication
    * 참고) https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application
    * 스프링 실행
      ```java
      SpringApplication.run(Application.class, args);
      // ↑ 요렇게 쓰면 스프링 애플리케이션이 제공하는 다양한 커스터마이징 기능을 사용하기가 어렵다.
      ```
      * 커스터마이징 가능 ← 인스턴스를 만들어서 활용하는 방식
      ```java
      SpringApplication app = new SpringApplication(Application.class);
      app.run(args);
      // ↑ 위의 코드와 결과는 동일하지만 커스터마이징이 가능함.
      ```
      * Application.class : @SpringBootApplication 애노테이션 붙인 클래스
    * 기본 로그 레벨 : INFO
      * 추후에 더 살펴볼 예정
      * 인텔리제이 실행 옵션에서 "VM Option:" 에 "-Ddebug" 를 설정하거나 "Program arguments" 에 "--debgug" 값을 설정하면 디버그 모드로 애플리케이션이 동작. 로그도 디버그 레벨까지 내려감.
        * 디버그 레벨로 로그 찍을 때 어떤 자동설정이 적용됐는지, 왜 적용이 안됐는지 파악 가능.
    * FailureAnalyzer
      * 에러메세지를 좀 더 예쁘게 출력해주는 기능.
      * 레퍼런스 문서 참고
    * 배너
      * banner.txt | gif | jpg | png
      * classpath 또는 spring.banner.location
        * application.properties 에서 설정
      * ${spring-boot.version} 등의 변수를 사용할 수 있음.
        * 일부 변수는 MF 파일 생성되어야 사용 가능. (jar로 패키징 한 후 실행하면 보임)
      * Banner 클래스 구현하고 SpringApplication.setBanner()로 설정 가능.
      * 배너 끄는 방법
        * SpringApplication.setBannerMode(Banner.Mode.OFF)
    * SpringApplicationBuilder로 빌더 패턴 사용 가능
      * 커스터마이징 가능
      ```java
      @SpringBootApplication
      public class Application {
          public static void main(String[] args) {
              new SpringApplicationBuilder()
                      .sources(Application.class)
                      .run(args);
          }
      }
      ```
    * ApplicationEvent 등록
      * 참고) https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners
      * ApplicationContext를 만들기 전에 사용하는 리스너는 @Bean으로 등록할 수 없다. 대신 아래와 같이 활용.
        * SpringApplication.addListeners()
          ```java
          /* SampleListener.java */
          public class SampleListener implements ApplicationListener<ApplicationStartingEvent> {

              @Override
              public void onApplicationEvent(ApplicationStartingEvent applicationStartingEvent) {
                  System.out.println("=======================");
                  System.out.println("Application is starting");
                  System.out.println("=======================");
              }
          }
          ```
          ```java
          /* Application.java */
          @SpringBootApplication
          public class Application {
              public static void main(String[] args) {
                  SpringApplication app = new SpringApplication(Application.class);
                  app.addListeners(new SampleListener());
                  app.setWebApplicationType(WebApplicationType.NONE);
                  app.run(args);
              }
          }
          ```
      * ApplicationContext를 만든 이후에 사용하는 리스너는 @Bean으로 등록 가능.
        ```java
        /* SampleListener.java */
        @Component
        public class SampleListener2 implements ApplicationListener<ApplicationStartedEvent> {
            @Override
            public void onApplicationEvent(ApplicationStartedEvent applicationStartedEvent) {
                System.out.println("=======================");
                System.out.println("Started");
                System.out.println("=======================");
            }
        }
        ```
        ```java
        /* Application.java */
        @SpringBootApplication
        public class Application {
            public static void main(String[] args) {
                SpringApplication app = new SpringApplication(Application.class);
                app.setWebApplicationType(WebApplicationType.NONE);
                app.run(args);
            }
        }
        ```
    * WebApplicationType 설정
      * WebApplicationType.NONE / .SERVLET / .REACTIVE 존재
        * 기본적으로 서블릿 웹 MVC가 있으면 SERVLET로 동작. 스프링 WebFlux가 들어있으면 REACTIVE로 동작.
          * 서블릿이 없고 리액티브만 있으면 리액티브로 동작하지만 서블릿이 있으면 무조건 서블릿으로 동작. 둘 다 없으면 NONE.
            * 서블릿도 있고 WebFlux도 있는데 그 상황에서 WebFlux를 선택하고자 하면 `app.setWebApplicationType(WebApplicationType.REACTIVE)`
        ```java
        /* Application.java */
        @SpringBootApplication
        public class Application {
            public static void main(String[] args) {
                SpringApplication app = new SpringApplication(Application.class);
                app.setWebApplicationType(WebApplicationType.NONE);
                app.run(args);
            }
        }
        ```
    * 애플리케이션 아규먼트 사용하기
      * 인텔리제이 실행 설정의 "Program arguments:" 부분에 "--" 로 값 넣어주는 영역
      * "VM options:" 부분은 JVM 옵션임. JVM 옵션은 애플리케이션 argument가 아님!
        * 예) VM options: "-Dfoo" / Program arguments: "--bar"
          ```java
          /* ArgsCheck.java */
          @Component
          public class ArgsCheck {

              // 어떤 Bean의 생성자가 한개이고 그 생성자의 파라미터가 Bean일 경우 그 Bean을 스프링이 알아서 주입해줌
              public ArgsCheck(ApplicationArguments arguments) {
                  // foo: false
                  // bar: true
                  System.out.println("foo: " + arguments.containsOption("foo"));
                  System.out.println("foo: " + arguments.containsOption("bar"));
              }
          }
          ```
          * maven jar 패키징 이후에 `java -jar spring-boot-getting-started-1.0-SNAPSHOT.jar -Dfoo --bar` 로 실행해도 동일함
***
