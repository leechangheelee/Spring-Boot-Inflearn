## **스프링 부트 활용**
  * 테스트 (Junit4)
    * 샘플 코드
      ```java
      /* sample/SampleController.java */
      ...
      @RestController
      public class SampleController {

          @Autowired
          private SampleService sampleService;

          @GetMapping("/hello")
          public String hello() {
              return "hello " + sampleService.getName();
          }
      }
      ```
      ```java
      /* sample/SampleService.java */
      ...
      @Service
      public class SampleService {

          public String getName() {
              return "changhee";
          }
      }
      ```
    * 시작은 일단 spring-boot-starter-test를 추가하는 것 부터
      * test 스콥으로 추가
        ```xml
        <!--pom.xml-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        ```
      * @SpringBootTest
        * @RunWith(SpringRunner.class)랑 같이 써야 함
        * 가장 기본적인 테스트 코드
          ```java
          ...
          @RunWith(SpringRunner.class)
          @SpringBootTest
          public class SampleControllerTest {
          
          }
          ```
        * 빈 설정 파일은 설정 안해주나? 알아서 찾는다 (@SpringBootApplication)
        * webEnvironment
          * MOCK: mock servlet environment. 내장 톰캣 구동 안함
            ```java
            /* SampleControllerTest.java */
            ...
            @RunWith(SpringRunner.class)
            @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)
            // ↑ 서블릿 컨테이너를 테스트용으로 띄우지 않고 목업을 해서 서블릿을 모킹한게뜬다.
            // ↓ 목업이 된 서블릿과 interaction 을 하려면 MockMvc 라는 클라이언트를 꼭 사용해야 한다.
            @AutoConfigureMocMvc
            public class SampleControllerTest {

                @Autowired
                MockMvc mockMvc;

                @Test
                public void hello() throws Exception {
                    mockMvc.perform(get("/hello"))
                            .andExpect(status().isOk()) //result matcher 에 있는걸 가져와야함
                            .andExpect(content().string("hello changhee"))
                            .andDo(print()); // print 로 찍은 내용을 다 assertion 할 수 있다
                }
            }
            ```
          * RANDOM_PORT, DEFINED_PORT: 내장 톰캣 사용함
            ```java
            /* SampleControllerTest.java */
            ...
            @RunWith(SpringRunner.class)
            @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) // ← 실제로 톰캣이 뜬다
            public class SampleControllerTest {

                // 이때 부터는 MockMvc를 쓰는게 아니라
                // test용 rest templete 이나 test용 web client 를 써야함
                @Autowired
                TestRestTemplete testRestTemplete;

                @Test
                public void hello() throws Exception {
                    String result = testRestTemplate.getForObject("/hello", String.class); // ← 내장 톰캣 서버에 실제로 요청을 보냄
                    assertThat(result).isEqualTo("hello changhee");
                }
            }
            ```
          * NONE: 서블릿 환경 제공 안함
        * @MockBean ← '나는 테스트 할때 service 단 까지 가고싶지 않아. 컨트롤러만 테스트 하고 싶어' 와 같을 때 사용
          * ApplicationContext에 들어있는 빈을 Mock으로 만든 객체로 교체함
          * 모든 @Test 마다 자동으로 리셋
            ```java
            /* SampleControllerTest.java */
            ...
            @RunWith(SpringRunner.class)
            @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
            public class SampleControllerTest {

                @Autowired
                TestRestTemplete testRestTemplete;
                
                @MockBean
                SampleService mockSampleService;
                // ApplicationContext 안에 들어있는 SampleService 빈을
                // 여기서 만든 mock 빈으로 교체함
                // 그래서 SampleController 는 아래 부분에서 mockSampleService를 쓰게됨. 원본이 아니라.
                // @Autowired 
                // private SampleService sampleService;

                @Test
                public void hello() throws Exception {
                    // 이때 부터는 모킹을 할 수 있다.
                    when(mockSampleService.getName()).thenReturn("leechangheelee");
                
                    String result = testRestTemplate.getForObject("/hello", String.class);
                    assertThat(result).isEqualTo("hello leechangheelee");
                }
            }
            ```
            * TestRestTemplate → WebTestClient 사용 (스프링5 web flux 에 추가된 rest client 중 하나. Asynchronous 임)
              ```xml
              <!--pom.xml-->
              <dependency>
                  <groupId>org.springframework.boot</groupId>
                  <artifactId>spring-boot-starter-webflux</artifactId>
              </dependency>
              ```
              ```java
              /* SampleControllerTest.java */
              ...
              @RunWith(SpringRunner.class)
              @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
              public class SampleControllerTest {

                  @Autowired
                  WebTestClient webTestClient;

                  @MockBean
                  SampleService mockSampleService;

                  @Test
                  public void hello() throws Exception {
                      when(mockSampleService.getName()).thenReturn("leechangheelee");

                      webTestClient.get().uri("/hello").exchange()
                              .expectStatus().isOk()
                              .expectBody(String.class).isEqualTo("hello leechangheelee");
                      // 다 chained API로 되어있어서 좀 더 rest template, mockMvc 보다 코딩하기가 편리함
                      // Asynchronous 가 쓰고싶어서가 아니더라도 API 가 편리해서 사용할 것 같다. (백기선 님)
                  }
              }
              ```
