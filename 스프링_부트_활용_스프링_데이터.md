## **스프링 부트 활용**
  * 스프링 데이터 - 소개
    * SQL DB
      * 인메모리 데이터베이스 지원
      * DataSource 설정
      * DBCP 설정
      * JDBC 사용하기
      * 스프링 데이터 JPA 사용하기
      * jOOQ 사용하기
      * 데이터베이스 초기화
      * 데이터베이스 마이그레이션 툴 연동하기
    * NoSQL
      * Redis (Key/Value)
      * MongoDB (Document)
      * Jeo4J (Graph)
***
  * 스프링 데이터 - 인메모리 데이터베이스
    * 지원하는 인-메모리 데이터베이스
      * __H2 (추천, 콘솔 때문에...)__
      * HSQL
      * Derby
    * Spring-JDBC가 클래스패스에 있으면 자동 설정이 필요한 빈을 설정해줌 (빈 주입받아 사용하면 됨)
      * DataSource
      * JdbcTemplate
    * 인-메모리 데이터베이스 기본 연결 정보 확인하는 방법
      * URL: "testdb"
      * username: "sa"
      * password: ""
    * H2 콘솔 사용하는 방법
      * spring-boot-devtools를 추가하거나
      * spring.h2.console.enabled=true 만 추가.
        ```
        #application.properties
        spring.h2.console.enabled=true
        ```
      * /h2-console로 접속 (이 path도 바꿀 수 있음)  
        `http://localhost:8080/h2-console`
    ```xml
    <!--
    pom.xml
    JDBC, H2 추가
    -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
    ```
    ```java
    /* H2Runner.java */
    ...
    @Component
    public class H2Runner implements ApplicationRunner {

        @Autowired
        DataSource dataSource;

        @Autowired
        JdbcTemplate jdbcTemplate;

        @Override
        public void run(ApplicationArguments args) throws Exception {
            try (Connection connection = dataSource.getConnection()) {
                // ↑ connection 이라는 리소스를 아래 블럭 안에서 사용하고
                // 안에서 무슨 문제가 생기든 꼭 정리를 해줌
                // 명시적으로 finally 블럭을 써서 정리할 (close 등) 필요 없음 (Java8 기능)

                System.out.println("URL : " + connection.getMetaData().getURL());
                System.out.println("USER NAME : " + connection.getMetaData().getUserName());

                Statement statement = connection.createStatement();
                String sql = "CREATE TABLE USER(ID INTEGER NOT NULL, name VARCHAR(255), PRIMARY KEY (id))";
                statement.executeUpdate(sql);
            }

            // 스프링 JDBC가 제공하는 JdbcTemplate을 사용하면
            // 훨씬 코드를 간결하고 안전하게 SQL 사용가능
            // 예외 발생시 좀 더 가독성 좋은 에러메세지 확인 가능
            jdbcTemplate.execute("INSERT INTO USER VALUES (1, 'changhee')");
        }
    }
    ```
***
  * 스프링 데이터 - MySQL
    * 지원하는 DBCP
      * DBCP
        * Database Connection Pool
        * 데이터베이스 커넥션을 만드는 과정이 상당히 많은 작업이 이루어짐. 커넥션을 미리 여러 개 만들어 놓고 애플리케이션이 필요로 할 때 마다 그때그때 미리 만들어져 있는 커넥션을 가져다가 쓰는 개념.
          * 미리 만들 때 얼마를 몇 개를 만들 것이냐
          * 얼마동안 안쓰이면 몇 개를 없앨 것이냐
          * 최소한 몇 개를 유지할 것이냐
          * 최소한 얼마동안 안에 커넥션을 애플리케이션에 전달 못하면 에러를 던질 것이냐 등의 여러가지 설정을 할 수 있음
        * 애플리케이션 성능에도 핵심적인 역할을 하기 때문에 영향을 미침
      * HikariCP (기본)
        * https://github.com/brettwooldridge/HikariCP#frequently-used
      * Tomcat CP
        * https://tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html
      * Commons DBCP2
        * https://commons.apache.org/proper/commons-dbcp/
    * DBCP 설정
      * __spring.datasource.hikari.*__
        ```
        #application.properties
        spring.datasource.hikari.maximum-pool-size=4
        ```
      * spring.datasource.tomcat.*
      * spring.datasource.dbcp2.*
    * MySQL 커넥터 의존성 추가 (DataSource 구현체이기도 함)
      ```xml
      <!-- pom.xml -->
      <dependency>
          <groupId>mysql</groupId>
          <artifactId>mysql-connector-java</artifactId>
      </dependency>
      ```
    * MySQL 추가 (도커 사용)
      * docker run -p 3306:3306 --name __mysql_boot__ -e MYSQL_ROOT_PASSWORD=__1__ -e MYSQL_DATABASE=__springboot__ -e MYSQL_USER=__changhee__ -e MYSQL_PASSWORD=__pass__ -d mysql
      * docker exec -i -t mysql_boot bash
      * mysql -u root -p
    * MySQL용 Datasource 설정
      * spring.datasource.url=jdbc:mysql://localhost:3306/springboot?useSSL=false
      * spring.datasource.username=changhee
      * spring.datasource.password=pass
        ```
        #application.properties
        spring.datasource.url=jdbc:mysql://localhost:3306/springboot?useSSL=false
        spring.datasource.username=changhee
        spring.datasource.password=pass
        ```
    * MySQL 접속시 에러
      * MySQL 5.* 최신 버전 사용할 때
        * 문제
          ```
          Sat Jul 21 11:17:59 PDT 2018 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.
          ```
        * 해결  
          `jdbc:mysql://localhost:3306/springboot?useSSL=false`
      * MySQL 8.* 최신 버전 사용할 때
        * 문제
          ```
          com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Public Key Retrieval is not allowed
          ```
        * 해결  
          `jdbc:mysql://localhost:3306/springboot?useSSL=false&allowPublicKeyRetrieval=true`
    * MySQL 라이센스 (GPL) 주의
      * MySQL 대신 MariaDB 사용 검토
      * 소스 코드 공개 의무 여부 확인
    ```java
    /* MySQLRunner.java */
    ...
    @Component
    public class MySQLRunner implements ApplicationRunner {

        @Autowired
        DataSource dataSource;

        @Autowired
        JdbcTemplate jdbcTemplate;

        @Override
        public void run(ApplicationArguments args) throws Exception {
            try (Connection connection = dataSource.getConnection()) {

                System.out.println(dataSource.getClass()); // 어떤 DBCP를 사용하는지 확인
                // class com.zaxxer.hikari.HikariDataSource
                System.out.println("URL : " + connection.getMetaData().getURL());
                // URL : jdbc:mysql://localhost:3306/springboot?useSSL=false
                System.out.println("USER NAME : " + connection.getMetaData().getUserName());
                // USER NAME : changhee@172.17.0.1

                Statement statement = connection.createStatement();
                String sql = "CREATE TABLE USER(ID INTEGER NOT NULL, name VARCHAR(255), PRIMARY KEY (id))";
                statement.executeUpdate(sql);
            }

            jdbcTemplate.execute("INSERT INTO USER VALUES (1, 'changhee')");
        }
    }
    ```
***
  * 스프링 데이터 - PostgreSQL
    * 의존성 추가
      ```xml
      <!-- pom.xml -->
      <dependency>
          <groupId>org.postgresql</groupId>
          <artifactId>postgresql</artifactId>
      </dependency>
      ```
    * PostgreSQL 설치 및 서버 실행 (docker)
      ```
      docker run -p 5432:5432 -e POSTGRES_PASSWORD=pass -e POSTGRES_USER=changhee -e POSTGRES_DB=springboot --name postgres_boot -d postgres
      docker exec -i -t postgres_boot bash
      psql -U changhee springboot

      데이터베이스 조회
      \list

      테이블 조회
      \dt

      쿼리
      SELECT * FROM account;
      ```
    * PostgreSQL 경고 메세지
      * 경고  
        `org.postgresql.jdbc.PgConnection.createClob() is not yet implemented`
      * 해결  
        `spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true`
    ```
    #application.properties
    spring.datasource.url=jdbc:postgresql://localhost:5432/springboot
    spring.datasource.username=changhee
    spring.datasource.password=pass
    ```
    ```java
    /* PgSQLRunner.java */
    ...
    @Component
    public class PgSQLRunner implements ApplicationRunner {

        @Autowired
        DataSource dataSource;

        @Autowired
        JdbcTemplate jdbcTemplate;

        @Override
        public void run(ApplicationArguments args) throws Exception {
            try (Connection connection = dataSource.getConnection()) {

                System.out.println(dataSource.getClass());
                // class com.zaxxer.hikari.HikariDataSource
                System.out.println("DRIVER : " + connection.getMetaData().getDriverName()); // 실질적으로 어떤 드라이버 쓰는지 확인가능
                // DRIVER : PostgreSQL JDBC Driver
                System.out.println("URL : " + connection.getMetaData().getURL());
                // URL : jdbc:postgresql://localhost:5432/springboot
                System.out.println("USER NAME : " + connection.getMetaData().getUserName());
                // USER NAME : changhee

                Statement statement = connection.createStatement();
                String sql = "CREATE TABLE account(ID INTEGER NOT NULL, name VARCHAR(255), PRIMARY KEY (id))";
                // postgres 에서는 USER 가 키워드여서 다른이름으로 테이블명 설정
                statement.executeUpdate(sql);
            }

            jdbcTemplate.execute("INSERT INTO account VALUES (1, 'changhee')");
        }
    }
    ```
***
  * 스프링 데이터 - 스프링 데이터 JPA
    * ORM(Object-Relational Mapping)과 JPA (Java Persistence API)
      * 객체와 릴레이션을 맵핑할 때 발생하는 개념적 불일치를 해결하는 프레임워크
      * https://hibernate.org/orm/what-is-an-orm/
      * JPA : ORM을 위한 자바 (EE) 표준
    * 스프링 데이터 JPA
      * Repository 빈 자동생성
      * 쿼리 메소드 자동구현
      * @EnableJpaRepositories (스프링 부트가 자동으로 설정해줌)
      * SDJ (Spring Data JPA) → JPA → Hibernate → Datasource
        * Spring Data JDBC 의 기능을 전부 다 사용할 수 있음
        * 그러면서도 부가적으로 SDJ → JPA → Hibernate 이 기능들을 더 사용할 수 있음
***
  * 스프링 데이터 - Spring-Data-JPA 연동
    * 스프링 데이터 JPA 의존성 추가
      ```xml
      <!-- pom.xml -->
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-data-jpa</artifactId>
      </dependency>
      ```
    * 스프링 데이터 JPA 사용하기
      * @Entity 클래스 만들기
        ```java
        /* account/Account.java */
        ...
        @Entity
        public class Account {

            @Id @GeneratedValue
            private Long id; // @GeneratedValue 리파지토리를 통해 저장할때 자동으로 생성된 값 사용

            private String username;

            private String password;

            public Long getId() {
                return id;
            }

            public void setId(Long id) {
                this.id = id;
            }

            public String getUsername() {
                return username;
            }

            public void setUsername(String username) {
                this.username = username;
            }

            public String getPassword() {
                return password;
            }

            public void setPassword(String password) {
                this.password = password;
            }

            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;
                Account account = (Account) o;
                return Objects.equals(id, account.id) && Objects.equals(username, account.username) && Objects.equals(password, account.password);
            }

            @Override
            public int hashCode() {
                return Objects.hash(id, username, password);
            }

            // lombok 사용 가능하면 위처럼 코딩 안하고 lombok 사용해도 됨
        }
        ```
      * Repository 만들기
        ```java
        /* account/AccountRepository.java */
        ...
        public interface AccountRepository extends JpaRepository<Account, Long> {
            Optional<Account> findByUsername(String username);
        }
        ```
    * 스프링 데이터 리파지토리 테스트 만들기
      * H2 DB를 테스트 의존성에 추가하기
        ```xml
        <!-- pom.xml -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
        ```
      * 애플리케이션 실행을 위한 설정
        ```xml
        <!-- pom.xml -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
        </dependency>
        ```
        ```
        #application.properties
        #애플리케이션은 postgresql 사용
        #인메모리 데이터베이스를 사용하는 경우가 아니라면 url 을 설정해줘야 함
        spring.datasource.url=jdbc:postgresql://localhost:5432/springboot
        spring.datasource.username=changhee
        spring.datasource.password=pass

        #애플리케이션에서는 아래 설정 필요
        spring.jpa.hibernate.ddl-auto=update
        ```
      * @DataJpaTest (슬라이스 테스트) 작성
        ```java
        /* AccountRepositoryTest.java */
        ...
        @RunWith(SpringRunner.class)
        @DataJpaTest
        // 리파지토리 포함 리파지토리와 관련된 빈들만 등록을 해서 테스트하는게 슬라이싱 테스트
        // 슬라이싱 테스트를 할 때는 임베디드 데이터베이스 (인메모리 데이터베이스) 가 반드시 필요함
        // → H2 DB를 테스트 의존성에 추가
        public class AccountRepositoryTest {

            @Autowired
            DataSource dataSource;

            @Autowired
            JdbcTemplate jdbcTemplate;

            @Autowired
            AccountRepository accountRepository;

            // 본격적으로 테스트 하기 전 몇 가지 확인
            // 잘 뜨는지 비어있는 테스트 돌림
            // 빈이 잘 등록되는지, 테스트 애플리케이션이 잘 실행되는지
            @Test
            public void di() throws SQLException {
                try(Connection connection = dataSource.getConnection()) {
                    DatabaseMetaData metaData = connection.getMetaData();
                    System.out.println(metaData.getURL());
                    System.out.println(metaData.getDriverName());
                    System.out.println(metaData.getUserName());
                    // (애플리케이션을 띄울때는 postgresql 을 사용하고)
                    // 테스트 할 때는 h2 를 사용하는 것을 보다 직접적으로 확인 가능
                }
            }

            @Test
            public void checking() {
                Account account = new Account();
                account.setUsername("changhee");
                account.setPassword("pass");

                Account newAccount = accountRepository.save(account);

                assertThat(newAccount).isNotNull();

                Optional<Account> existingAccount = accountRepository.findByUsername(newAccount.getUsername());
                assertThat(existingAccount).isNotEmpty();
                // Optional 도 사용 가능하고 리턴값은 null 이 아님
                // Optional용 assert 를 써야함

                Optional<Account> nonExistingAccount = accountRepository.findByUsername("INVALID_USERNAME");
                // 우리는 findByUsername 이라는 메소드만 추가했을 뿐인데 이거에 대한 실제 구현체를 만들어서 빈으로 등록해주는 것 까지
                // Spring Data JPA가 알아서 해주는 것
                assertThat(nonExistingAccount).isEmpty();
            }
        }

        //@RunWith(SpringRunner.class)
        //@SpringBootTest
        //// Integration Test
        //// 애플리케이션에 있는 모든 빈이 다 등록됨 (application.properties 도 적용됨)
        //public class AccountRepositoryTest {
        //
        //    @Autowired
        //    DataSource dataSource;
        //
        //    @Autowired
        //    JdbcTemplate jdbcTemplate;
        //
        //    @Autowired
        //    AccountRepository accountRepository;
        //
        //    @Test
        //    public void di() throws SQLException {
        //        try(Connection connection = dataSource.getConnection()) {
        //            DatabaseMetaData metaData = connection.getMetaData();
        //            System.out.println(metaData.getURL());
        //            System.out.println(metaData.getDriverName());
        //            System.out.println(metaData.getUserName());
        //            // @SpringBootTest 애노테이션에 따라 postgresql 를 사용하게 됨 (테스트용 DB가 필요)
        //            // @SpringBootTest(properties = "spring.datasource.url=jdbc:postgresql://abcd") 등 별도 설정 없으면 애플리케이션이 붙는 DB에서 작업이 이뤄짐
        //            // 테스트를 돌릴때는 임베디드 DB를 쓰는게 좀 더 빠름
        //        }
        //    }
        //}
        ```
