## **스프링 부트 활용**
  * 스프링 데이터 - 소개
    * SQL DB
      * 인메모리 데이터베이스 지원
      * DataSource 설정
      * DBCP 설정
      * JDBC 사용하기
      * 스프링 데이터 JPA 사용하기
      * jOOQ 사용하기
      * 데이터베이스 초기화
      * 데이터베이스 마이그레이션 툴 연동하기
    * NoSQL
      * Redis (Key/Value)
      * MongoDB (Document)
      * Jeo4J (Graph)
***
  * 스프링 데이터 - 인메모리 데이터베이스
    * 지원하는 인-메모리 데이터베이스
      * __H2 (추천, 콘솔 때문에...)__
      * HSQL
      * Derby
    * Spring-JDBC가 클래스패스에 있으면 자동 설정이 필요한 빈을 설정해줌 (빈 주입받아 사용하면 됨)
      * DataSource
      * JdbcTemplate
    * 인-메모리 데이터베이스 기본 연결 정보 확인하는 방법
      * URL: "testdb"
      * username: "sa"
      * password: ""
    * H2 콘솔 사용하는 방법
      * spring-boot-devtools를 추가하거나
      * spring.h2.console.enabled=true 만 추가.
        ```
        #application.properties
        spring.h2.console.enabled=true
        ```
      * /h2-console로 접속 (이 path도 바꿀 수 있음)  
        `http://localhost:8080/h2-console`
    ```xml
    <!--
    pom.xml
    JDBC, H2 추가
    -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
    ```
    ```java
    /* H2Runner.java */
    ...
    @Component
    public class H2Runner implements ApplicationRunner {

        @Autowired
        DataSource dataSource;

        @Autowired
        JdbcTemplate jdbcTemplate;

        @Override
        public void run(ApplicationArguments args) throws Exception {
            try (Connection connection = dataSource.getConnection()) {
                // ↑ connection 이라는 리소스를 아래 블럭 안에서 사용하고
                // 안에서 무슨 문제가 생기든 꼭 정리를 해줌
                // 명시적으로 finally 블럭을 써서 정리할 (close 등) 필요 없음 (Java8 기능)

                System.out.println("URL : " + connection.getMetaData().getURL());
                System.out.println("USER NAME : " + connection.getMetaData().getUserName());

                Statement statement = connection.createStatement();
                String sql = "CREATE TABLE USER(ID INTEGER NOT NULL, name VARCHAR(255), PRIMARY KEY (id))";
                statement.executeUpdate(sql);
            }

            // 스프링 JDBC가 제공하는 JdbcTemplate을 사용하면
            // 훨씬 코드를 간결하고 안전하게 SQL 사용가능
            // 예외 발생시 좀 더 가독성 좋은 에러메세지 확인 가능
            jdbcTemplate.execute("INSERT INTO USER VALUES (1, 'changhee')");
        }
    }
    ```
***
  * 스프링 데이터 - MySQL
    * 지원하는 DBCP
      * DBCP
        * Database Connection Pool
        * 데이터베이스 커넥션을 만드는 과정이 상당히 많은 작업이 이루어짐. 커넥션을 미리 여러 개 만들어 놓고 애플리케이션이 필요로 할 때 마다 그때그때 미리 만들어져 있는 커넥션을 가져다가 쓰는 개념.
          * 미리 만들 때 얼마를 몇 개를 만들 것이냐
          * 얼마동안 안쓰이면 몇 개를 없앨 것이냐
          * 최소한 몇 개를 유지할 것이냐
          * 최소한 얼마동안 안에 커넥션을 애플리케이션에 전달 못하면 에러를 던질 것이냐 등의 여러가지 설정을 할 수 있음
        * 애플리케이션 성능에도 핵심적인 역할을 하기 때문에 영향을 미침
      * HikariCP (기본)
        * https://github.com/brettwooldridge/HikariCP#frequently-used
      * Tomcat CP
        * https://tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html
      * Commons DBCP2
        * https://commons.apache.org/proper/commons-dbcp/
    * DBCP 설정
      * __spring.datasource.hikari.*__
        ```
        #application.properties
        spring.datasource.hikari.maximum-pool-size=4
        ```
      * spring.datasource.tomcat.*
      * spring.datasource.dbcp2.*
    * MySQL 커넥터 의존성 추가 (DataSource 구현체이기도 함)
      ```xml
      <!-- pom.xml -->
      <dependency>
          <groupId>mysql</groupId>
          <artifactId>mysql-connector-java</artifactId>
      </dependency>
      ```
    * MySQL 추가 (도커 사용)
      * docker run -p 3306:3306 --name __mysql_boot__ -e MYSQL_ROOT_PASSWORD=__1__ -e MYSQL_DATABASE=__springboot__ -e MYSQL_USER=__changhee__ -e MYSQL_PASSWORD=__pass__ -d mysql
      * docker exec -i -t mysql_boot bash
      * mysql -u root -p
    * MySQL용 Datasource 설정
      * spring.datasource.url=jdbc:mysql://localhost:3306/springboot?useSSL=false
      * spring.datasource.username=changhee
      * spring.datasource.password=pass
        ```
        #application.properties
        spring.datasource.url=jdbc:mysql://localhost:3306/springboot?useSSL=false
        spring.datasource.username=changhee
        spring.datasource.password=pass
        ```
    * MySQL 접속시 에러
      * MySQL 5.* 최신 버전 사용할 때
        * 문제
          ```
          Sat Jul 21 11:17:59 PDT 2018 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.
          ```
        * 해결  
          `jdbc:mysql://localhost:3306/springboot?useSSL=false`
      * MySQL 8.* 최신 버전 사용할 때
        * 문제
          ```
          com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Public Key Retrieval is not allowed
          ```
        * 해결  
          `jdbc:mysql://localhost:3306/springboot?useSSL=false&allowPublicKeyRetrieval=true`
    * MySQL 라이센스 (GPL) 주의
      * MySQL 대신 MariaDB 사용 검토
      * 소스 코드 공개 의무 여부 확인
    ```java
    /* MySQLRunner.java */
    ...
    @Component
    public class MySQLRunner implements ApplicationRunner {

        @Autowired
        DataSource dataSource;

        @Autowired
        JdbcTemplate jdbcTemplate;

        @Override
        public void run(ApplicationArguments args) throws Exception {
            try (Connection connection = dataSource.getConnection()) {

                System.out.println(dataSource.getClass()); // 어떤 DBCP를 사용하는지 확인
                // class com.zaxxer.hikari.HikariDataSource
                System.out.println("URL : " + connection.getMetaData().getURL());
                // URL : jdbc:mysql://localhost:3306/springboot?useSSL=false
                System.out.println("USER NAME : " + connection.getMetaData().getUserName());
                // USER NAME : changhee@172.17.0.1

                Statement statement = connection.createStatement();
                String sql = "CREATE TABLE USER(ID INTEGER NOT NULL, name VARCHAR(255), PRIMARY KEY (id))";
                statement.executeUpdate(sql);
            }

            jdbcTemplate.execute("INSERT INTO USER VALUES (1, 'changhee')");
        }
    }
    ```
***
  * 스프링 데이터 - PostgreSQL
    * 의존성 추가
      ```xml
      <!-- pom.xml -->
      <dependency>
          <groupId>org.postgresql</groupId>
          <artifactId>postgresql</artifactId>
      </dependency>
      ```
    * PostgreSQL 설치 및 서버 실행 (docker)
      ```
      docker run -p 5432:5432 -e POSTGRES_PASSWORD=pass -e POSTGRES_USER=changhee -e POSTGRES_DB=springboot --name postgres_boot -d postgres
      docker exec -i -t postgres_boot bash
      psql -U changhee springboot

      데이터베이스 조회
      \list

      테이블 조회
      \dt

      쿼리
      SELECT * FROM account;
      ```
    * PostgreSQL 경고 메세지
      * 경고  
        `org.postgresql.jdbc.PgConnection.createClob() is not yet implemented`
      * 해결  
        `spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true`
    ```
    #application.properties
    spring.datasource.url=jdbc:postgresql://localhost:5432/springboot
    spring.datasource.username=changhee
    spring.datasource.password=pass
    ```
    ```java
    /* PgSQLRunner.java */
    ...
    @Component
    public class PgSQLRunner implements ApplicationRunner {

        @Autowired
        DataSource dataSource;

        @Autowired
        JdbcTemplate jdbcTemplate;

        @Override
        public void run(ApplicationArguments args) throws Exception {
            try (Connection connection = dataSource.getConnection()) {

                System.out.println(dataSource.getClass());
                // class com.zaxxer.hikari.HikariDataSource
                System.out.println("DRIVER : " + connection.getMetaData().getDriverName()); // 실질적으로 어떤 드라이버 쓰는지 확인가능
                // DRIVER : PostgreSQL JDBC Driver
                System.out.println("URL : " + connection.getMetaData().getURL());
                // URL : jdbc:postgresql://localhost:5432/springboot
                System.out.println("USER NAME : " + connection.getMetaData().getUserName());
                // USER NAME : changhee

                Statement statement = connection.createStatement();
                String sql = "CREATE TABLE account(ID INTEGER NOT NULL, name VARCHAR(255), PRIMARY KEY (id))";
                // postgres 에서는 USER 가 키워드여서 다른이름으로 테이블명 설정
                statement.executeUpdate(sql);
            }

            jdbcTemplate.execute("INSERT INTO account VALUES (1, 'changhee')");
        }
    }
    ```
***
  * 스프링 데이터 - 스프링 데이터 JPA
    * ORM(Object-Relational Mapping)과 JPA (Java Persistence API)
      * 객체와 릴레이션을 맵핑할 때 발생하는 개념적 불일치를 해결하는 프레임워크
      * https://hibernate.org/orm/what-is-an-orm/
      * JPA : ORM을 위한 자바 (EE) 표준
    * 스프링 데이터 JPA
      * Repository 빈 자동생성
      * 쿼리 메소드 자동구현
      * @EnableJpaRepositories (스프링 부트가 자동으로 설정해줌)
      * SDJ (Spring Data JPA) → JPA → Hibernate → Datasource
